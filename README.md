# Approximate-String-Matching

This repository contains experimental scripts of approximate string matching algorithms.

- [x] Needleman-Wunsch Algorithm
- [ ] Landau-Vishkin Algorithm (backtracking missing)
- [x] LEAP

## Idea of Greedy Approximate String Matching Algorithm

1. Starting from the current position, We find the longest highway

```
hurdles
10000001110101100000111111110110011111111101001011111101111101111111111101100111101011101101111101011110011000011
10000000100000111110100000000000111011100101000101011111111111011101111111100011111101001001101111001111111000001
11000000011010100111111111111011101101111001000011111100101111101100110100000000010111111011100100000000000000000
11000000111111111010100001111110000111101110000000000111011110101100000111100011100100000101000000000000000000001
11000001011111111011011111111111010000000000000111111011100000110101101101100111100011111000011101011110011000011
After removing ones
10000001110001100000111111111110011111111100000011111111111111111111111111100111100011111111111100011110011000011
10000000000000111110000000000000111111100000000000011111111111111111111111100011111100000001111111001111111000001
11000000011000000111111111111111111111111000000011111100001111111100110000000000000111111111100000000000000000000
11000000111111111000000001111110000111111110000000000111111110001100000111100011100000000000000011001111111000001
11000000011111111111111111111111000000000000000111111111100000110001111111100111100011111000011100011110011000011
```

2. We project (using bitwise and) the highway to the lane of next highway to find the hurdle cost. For example, if we are leaping to lane 1,

```
hurdles
10000001110101100000111111110110011111111101001011111101111101111111111101100111101011101101111101011110011000011
10000000100000111110100000000000111011100101000101011111111111011101111111100011111101001001101111001111111000001
11000000011010100111111111111011101101111001000011111100000000101100110100000000010111111011100100000000000000000
11000000111111111010100001111110000111101110000000000111000000101100000111100011100100000101001000000000000000001
11000001011111111011011111111111010000000000000111111011100000110101101101100111100011111000011101011110011000011
After removing ones
10000001110001100000111111111110011111111100000011111111111111111111111111100111100011111111111100011110011000011
10000000000000111110000000000000111111100000000000011111111111111111111111100011111100000001111111001111111000001
11000000011000000111111111111111111111111000000011111100001111111100110000000000000111111111100000000000000000000
11000000111111111000000001111110000111111110000000000111111110001100000111100011100000000000000000000000000000001
11000000011111111111111111111111000000000000000111111111111100110001111111100111100011111000011100011110011000011
```




## Current problems with Greedy ASM Algorithm

1. It is not able to find the optimal path between highways. For example, an optimal match between two DNAs look like the following,

   ```
   AGAGCTAAAC-ATGGCCGCACATAAATCGTTTTGAG-TTGAA-A-CTTTACCGCTGCATCTA-TTTTTCTCCTAGAATTATACCGTACACAGCCGAC-GTTCCACC
   AGAGCTAAACAAGGGGCCCACATTAA-CGTTTTGAGCTTGAAGATCTTTACCGC-G-ATCTATTTTTTCTCCTAG-A-T-TACCGTACACA-CCGACACTTCCATC
   ```
   But GASMA will give the following results,
   ```
   AGAGCTAAACATGG-CCGCACATAAATCGTTTTGAGTT-GAA--ACTTTACCGCTGCATCTATTTT-TCTCCTAGAATTATACCGTACACAGCCG-ACGTTCCACC
   AGAGCTAAACAAGGGGCCCACATTAA-CGTTTTGAGCTTGAAGATCTTTACCGC--GATCTATTTTTTCTCCTAGAT---TACCGTACACACC-GACACTTCCATC
   ```

   As a result, the calculated edit distance is 24 instead of 19, which is optimal. For now I always switch lanes at the end of each highway and and then go directly to the next highway, so there will be some errors in between.
   
   **Potential solution**: Maybe use traditional DP to find optimal path between highways?

   **Potential solution 2**: Maybe we can also extract those high-speed bridges (like `G-A-T-T` above) and put them into considerations?

   **Potential solution 3**: Leave them as-is and 

2. There are currently too many parameters for GASMA. Including:

   - `z` Maximum length of streaks of zeros we are skipping
   - `o` Maximum length of streaks of ones we are skipping
   - `k` as in Banded Levenshtein distance problem
   - `sight` which indicates the range of highway we are choosing from

   And choosing those parameters can greatly affect performance.

   - `z=2, o=2, sight=3`, we have `MAE=2.396, CR=0.314`
   - `z=0, o=0, sight=3`, we have `MAE=1.29, CR=0.459`
   - `z=0, o=0, sight=5`, we have `MAE=2.002, CR=0.194`

3. Currently I abandoned the greedy algorithm that tried to find global optimum, because it is unstable when `k` goes large. Too many highways to consider also make it very slow.

## Current Benchmark Results

With 20,000 samples with random error rate, we can calculate the following statistics:

### Mean Absolute Error

The mean absolute error between result of GASMA and Needleman Wunsch

![](./pymatch/test/asset/MAE.png)


### Correct Rate

The proportion of test cases where GASMA correctly identified the optimal edit distance

![](./pymatch/test/asset/CR.png)

### Relative Error

The relative absolute error with respect to the optimal edit distance

![](./pymatch/test/asset/error_relative.png)